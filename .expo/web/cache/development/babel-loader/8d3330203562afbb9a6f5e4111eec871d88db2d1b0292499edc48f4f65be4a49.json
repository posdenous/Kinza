{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useCallback } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport useNetworkStatus from './useNetworkStatus';\nexport var useApiWithRetry = function useApiWithRetry(apiCall) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$maxRetries = options.maxRetries,\n    maxRetries = _options$maxRetries === void 0 ? 3 : _options$maxRetries,\n    _options$baseDelay = options.baseDelay,\n    baseDelay = _options$baseDelay === void 0 ? 1000 : _options$baseDelay,\n    _options$maxDelay = options.maxDelay,\n    maxDelay = _options$maxDelay === void 0 ? 10000 : _options$maxDelay,\n    _options$backoffMulti = options.backoffMultiplier,\n    backoffMultiplier = _options$backoffMulti === void 0 ? 2 : _options$backoffMulti,\n    _options$retryConditi = options.retryCondition,\n    retryCondition = _options$retryConditi === void 0 ? function (error) {\n      var _error$message, _error$message2;\n      return error.code === 'network-request-failed' || error.code === 'timeout' || ((_error$message = error.message) == null ? void 0 : _error$message.includes('timeout')) || ((_error$message2 = error.message) == null ? void 0 : _error$message2.includes('network')) || error.status >= 500 && error.status < 600;\n    } : _options$retryConditi;\n  var _useTranslation = useTranslation(),\n    t = _useTranslation.t;\n  var _useNetworkStatus = useNetworkStatus(),\n    isConnected = _useNetworkStatus.isConnected,\n    isInternetReachable = _useNetworkStatus.isInternetReachable;\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isRetrying = _useState2[0],\n    setIsRetrying = _useState2[1];\n  var _useState3 = useState(0),\n    _useState4 = _slicedToArray(_useState3, 2),\n    retryCount = _useState4[0],\n    setRetryCount = _useState4[1];\n  var sleep = function sleep(ms) {\n    return new Promise(function (resolve) {\n      return setTimeout(resolve, ms);\n    });\n  };\n  var calculateDelay = function calculateDelay(attempt) {\n    var delay = baseDelay * Math.pow(backoffMultiplier, attempt);\n    return Math.min(delay, maxDelay);\n  };\n  var execute = useCallback(_asyncToGenerator(function* () {\n    if (!isConnected || !isInternetReachable) {\n      throw new Error(t('errors.offline'));\n    }\n    var lastError;\n    var attempt = 0;\n    while (attempt <= maxRetries) {\n      try {\n        setIsRetrying(attempt > 0);\n        setRetryCount(attempt);\n        var result = yield apiCall();\n        setIsRetrying(false);\n        setRetryCount(0);\n        return result;\n      } catch (error) {\n        lastError = error;\n        if (attempt >= maxRetries) {\n          break;\n        }\n        if (!retryCondition(error)) {\n          break;\n        }\n        if (!isConnected || !isInternetReachable) {\n          throw new Error(t('errors.offline'));\n        }\n        var delay = calculateDelay(attempt);\n        yield sleep(delay);\n        attempt++;\n      }\n    }\n    setIsRetrying(false);\n    if (retryCount > 0) {\n      lastError.message = `${lastError.message} (${t('errors.retriedTimes', {\n        count: retryCount\n      })})`;\n    }\n    throw lastError;\n  }), [apiCall, maxRetries, retryCondition, isConnected, isInternetReachable, t, retryCount]);\n  var reset = useCallback(function () {\n    setIsRetrying(false);\n    setRetryCount(0);\n  }, []);\n  return {\n    execute: execute,\n    isRetrying: isRetrying,\n    retryCount: retryCount,\n    reset: reset\n  };\n};\nexport default useApiWithRetry;","map":{"version":3,"names":["useState","useCallback","useTranslation","useNetworkStatus","useApiWithRetry","apiCall","options","arguments","length","undefined","_options$maxRetries","maxRetries","_options$baseDelay","baseDelay","_options$maxDelay","maxDelay","_options$backoffMulti","backoffMultiplier","_options$retryConditi","retryCondition","error","_error$message","_error$message2","code","message","includes","status","_useTranslation","t","_useNetworkStatus","isConnected","isInternetReachable","_useState","_useState2","_slicedToArray","isRetrying","setIsRetrying","_useState3","_useState4","retryCount","setRetryCount","sleep","ms","Promise","resolve","setTimeout","calculateDelay","attempt","delay","Math","pow","min","execute","_asyncToGenerator","Error","lastError","result","count","reset"],"sources":["/Users/brianwilliams/Documents/GitHub/Kinza/src/hooks/common/useApiWithRetry.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport useNetworkStatus from './useNetworkStatus';\n\ninterface RetryOptions {\n  maxRetries?: number;\n  baseDelay?: number;\n  maxDelay?: number;\n  backoffMultiplier?: number;\n  retryCondition?: (error: any) => boolean;\n}\n\ninterface ApiRetryResult<T> {\n  execute: () => Promise<T>;\n  isRetrying: boolean;\n  retryCount: number;\n  reset: () => void;\n}\n\n/**\n * Custom hook for API calls with automatic retry logic and exponential backoff\n * @param apiCall - The API function to execute\n * @param options - Retry configuration options\n * @returns Object with execute function and retry state\n */\nexport const useApiWithRetry = <T>(\n  apiCall: () => Promise<T>,\n  options: RetryOptions = {}\n): ApiRetryResult<T> => {\n  const {\n    maxRetries = 3,\n    baseDelay = 1000,\n    maxDelay = 10000,\n    backoffMultiplier = 2,\n    retryCondition = (error) => {\n      // Retry on network errors, timeouts, and 5xx server errors\n      return (\n        error.code === 'network-request-failed' ||\n        error.code === 'timeout' ||\n        error.message?.includes('timeout') ||\n        error.message?.includes('network') ||\n        (error.status >= 500 && error.status < 600)\n      );\n    },\n  } = options;\n\n  const { t } = useTranslation();\n  const { isConnected, isInternetReachable } = useNetworkStatus();\n  const [isRetrying, setIsRetrying] = useState(false);\n  const [retryCount, setRetryCount] = useState(0);\n\n  const sleep = (ms: number): Promise<void> => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  };\n\n  const calculateDelay = (attempt: number): number => {\n    const delay = baseDelay * Math.pow(backoffMultiplier, attempt);\n    return Math.min(delay, maxDelay);\n  };\n\n  const execute = useCallback(async (): Promise<T> => {\n    // Check network connectivity first\n    if (!isConnected || !isInternetReachable) {\n      throw new Error(t('errors.offline'));\n    }\n\n    let lastError: any;\n    let attempt = 0;\n\n    while (attempt <= maxRetries) {\n      try {\n        setIsRetrying(attempt > 0);\n        setRetryCount(attempt);\n\n        const result = await apiCall();\n        \n        // Success - reset retry state\n        setIsRetrying(false);\n        setRetryCount(0);\n        \n        return result;\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry if we've reached max attempts\n        if (attempt >= maxRetries) {\n          break;\n        }\n\n        // Don't retry if the error doesn't meet retry conditions\n        if (!retryCondition(error)) {\n          break;\n        }\n\n        // Don't retry if we've lost network connection\n        if (!isConnected || !isInternetReachable) {\n          throw new Error(t('errors.offline'));\n        }\n\n        // Calculate delay and wait before retry\n        const delay = calculateDelay(attempt);\n        await sleep(delay);\n        \n        attempt++;\n      }\n    }\n\n    // All retries failed\n    setIsRetrying(false);\n    \n    // Enhance error message with retry information\n    if (retryCount > 0) {\n      lastError.message = `${lastError.message} (${t('errors.retriedTimes', { count: retryCount })})`;\n    }\n    \n    throw lastError;\n  }, [apiCall, maxRetries, retryCondition, isConnected, isInternetReachable, t, retryCount]);\n\n  const reset = useCallback(() => {\n    setIsRetrying(false);\n    setRetryCount(0);\n  }, []);\n\n  return {\n    execute,\n    isRetrying,\n    retryCount,\n    reset,\n  };\n};\n\nexport default useApiWithRetry;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}